## Задача 1. Список покупок

### Описание
Наверное, у каждого из нас есть списки желаемых покупок. Особенно перед праздниками.
Так давайте напишем программу для хранения этих "хотелок" так, чтобы они автоматически сортировались по какому-то признаку.

Что известно:
* Сущность "Хотелка": название (уникальное), краткое описание, цена, URL-адрес интернет-магазина или адрес магазина, 
приоритет (0 - 5, где 0 - очень низкий приоритет, а 5 - очень высокий приоритет).

### Функционал программы
1. Добавление "хотелок";
2. Сортировка по убыванию/возрастанию цены;
3. Сортировка по приоритету от самого важного до самого низкого приоритета.

### Пример
```
Выберите тип сортировки для Wishlist
1. Сортировка по убыванию цены
2. Сортировка по возрастанию цены
3. Сортировка по приоритету от самого важного
4. Сортировка по приоритету от низкого приоритета
Введите индентификатор сортировки:
1 <enter>
Введите что бы вы хотели купить (введите пустую строку для выхода):
Название
Яндекс станция <enter>
Короткое название
Алиса <enter>
Цена в рублях
10000 <enter>
Где купить
https://beru.ru/product/yandex-stantsiia-umnaia-kolonka-s-alisoi-vnutri-chernaia/100307940934 <enter>
Приоритет важности (0 - не очень важно, 5 - очень важно)
3 <enter>
Добавлено!
Введите что бы вы хотели купить (введите пустую строку для выхода):
<enter>
Ваш список:
  - Яндекс станция
```

### Реализация
1. Создадим классы Wish. Рекомендую использовать следующие типы данных: 
  * Название — String;
  * Краткое описание — String;
  * Цена — double;
  * URL-адрес интернет-магазина или адрес магазина — String;
  * Приоритет — int.
  
2. Для того чтобы мы могли изменять тип сортировки, в процессе выполнения программы будем использовать интерфейс Comparator, 
а не Comparable. Если мы будем имплементировать интерфейс Comparable на уровне сущности Wish, мы будем привязаны к какому-то типу сортировки, в то же время мы можем просто передавать в конструктор TreeSet желаемый Comparator. 
Важно: в уже созданном объекте TreeSet нельзя менять тип сортировки. 

3. Поэтому необходимо создать 2 класса, имплементирующих интерфейс Comparator<Wish> (один для сортировки по цене, 
второй для сортировки по приоритету), в которых нужно передавать в конструкторе направление сортировки и переопределить метод compare, используя направление сортировки из конструктора. Направление сортировки можно задавать, используя `enum`.

4. В начале работы программы спросите пользователя, как нужно сортировать "хотелки". 
```java
System.out.println("1. Сортировка по убыванию цены");
System.out.println("2. Сортировка по возрастанию цены");
System.out.println("3. Сортировка по приоритету от самого важного");
System.out.println("4. Сортировка по приоритету от низкого приоритета");
System.out.println("Введите идентификатор сортировки:");
String id = scanner.nextLine();
 ```

5. Затем создаем объект TreeSet и передаем в конструктор выбранный компаратор.

6. По аналогии с предыдущими заданиями, считываем сущности `Wish` с клавиатуры и добавляем в созданный объект TreeSet.
Для вывода объекта на экран переопределим метод `toString()`.

7. После ввода объектов выведем содержимое `TreeSet`, используя `iterator` или `forEach` цикл.

8. Для демонстрации работы программы создадим в коде при запуске программы несколько "хотелок" (> 10).


### Дополнительное задание
В дополнение к возможным действиям задачи 1 добавьте возможность, чтобы после ввода всех "хотелок" и вывода в консоль всех "хотелок" в выбранной сортировке, программа предлагала и дальше отсортировать уже созданный список "хотелок", как в пункте 4.
Это можно реализовать с помощью нового объекта TreeSet с выбранным Comparator и в него добавить содержимое старого TreeSet с помощью метода `addAll(Collection<? extends E> c)`.
